// Interactive overlay window with egui + winit

use super::types::*;
use super::selection::{check_window_snap, detect_windows, snap_to_window};
use super::capture::capture_screen_region;
use egui::{Color32, Pos2, Rect, Stroke, Vec2};
use std::sync::{Arc, Mutex};
use winit::event::{ElementState, Event, KeyEvent, MouseButton, WindowEvent};
use winit::event_loop::{ControlFlow, EventLoop};
use winit::keyboard::{KeyCode, PhysicalKey};
use winit::window::Window;

/// State for interactive overlay
pub struct OverlayState {
    /// Current selection region (if any)
    pub selection: Option<ScreenRegion>,
    /// Mouse drag start position
    pub drag_start: Option<Pos2>,
    /// Current mouse position
    pub mouse_pos: Pos2,
    /// Is currently dragging to create selection
    pub is_selecting: bool,
    /// Active resize handle (if any)
    pub active_handle: Option<ResizeHandle>,
    /// Detected windows for snapping
    pub windows: Vec<WindowSnapInfo>,
    /// Currently snapped window
    pub snapped_window: Option<WindowSnapInfo>,
    /// Options for this capture session
    pub options: InteractiveCaptureOptions,
    /// Whether capture is confirmed
    pub confirmed: bool,
    /// Whether capture is cancelled
    pub cancelled: bool,
}

impl OverlayState {
    pub fn new(options: InteractiveCaptureOptions) -> Self {
        let windows = detect_windows().unwrap_or_default();
        Self {
            selection: None,
            drag_start: None,
            mouse_pos: Pos2::ZERO,
            is_selecting: false,
            active_handle: None,
            windows,
            snapped_window: None,
            options,
            confirmed: false,
            cancelled: false,
        }
    }

    /// Update selection based on current mouse position
    pub fn update_selection(&mut self) {
        if let Some(start) = self.drag_start {
            let current = self.mouse_pos;

            // Calculate selection region from drag points
            let x = start.x.min(current.x) as i32;
            let y = start.y.min(current.y) as i32;
            let width = (start.x - current.x).abs() as u32;
            let height = (start.y - current.y).abs() as u32;

            if width > 0 && height > 0 {
                let mut region = ScreenRegion { x, y, width, height };

                // Check for window snapping
                if self.options.enable_window_snap {
                    if let Some(snapped) = check_window_snap(
                        &region,
                        &self.windows,
                        self.options.snap_threshold,
                    ) {
                        snap_to_window(&mut region, &snapped.region, &snapped.snap_edge);
                        self.snapped_window = Some(snapped);
                    } else {
                        self.snapped_window = None;
                    }
                }

                self.selection = Some(region);
            }
        }
    }

    /// Handle resize based on active handle
    pub fn resize_selection(&mut self) {
        if let (Some(mut region), Some(handle)) = (self.selection, self.active_handle) {
            let mouse_x = self.mouse_pos.x as i32;
            let mouse_y = self.mouse_pos.y as i32;

            match handle {
                ResizeHandle::TopLeft => {
                    let new_width = (region.x + region.width as i32 - mouse_x) as u32;
                    let new_height = (region.y + region.height as i32 - mouse_y) as u32;
                    region.x = mouse_x;
                    region.y = mouse_y;
                    region.width = new_width.max(10);
                    region.height = new_height.max(10);
                }
                ResizeHandle::TopRight => {
                    let new_height = (region.y + region.height as i32 - mouse_y) as u32;
                    region.y = mouse_y;
                    region.width = (mouse_x - region.x).max(10) as u32;
                    region.height = new_height.max(10);
                }
                ResizeHandle::BottomLeft => {
                    let new_width = (region.x + region.width as i32 - mouse_x) as u32;
                    region.x = mouse_x;
                    region.width = new_width.max(10);
                    region.height = (mouse_y - region.y).max(10) as u32;
                }
                ResizeHandle::BottomRight => {
                    region.width = (mouse_x - region.x).max(10) as u32;
                    region.height = (mouse_y - region.y).max(10) as u32;
                }
                ResizeHandle::Top => {
                    let new_height = (region.y + region.height as i32 - mouse_y) as u32;
                    region.y = mouse_y;
                    region.height = new_height.max(10);
                }
                ResizeHandle::Bottom => {
                    region.height = (mouse_y - region.y).max(10) as u32;
                }
                ResizeHandle::Left => {
                    let new_width = (region.x + region.width as i32 - mouse_x) as u32;
                    region.x = mouse_x;
                    region.width = new_width.max(10);
                }
                ResizeHandle::Right => {
                    region.width = (mouse_x - region.x).max(10) as u32;
                }
            }

            self.selection = Some(region);
        }
    }

    /// Get resize handle at mouse position
    pub fn get_handle_at_pos(&self, pos: Pos2) -> Option<ResizeHandle> {
        if let Some(region) = &self.selection {
            let threshold = 8.0; // Pixels from edge/corner

            let left = region.x as f32;
            let top = region.y as f32;
            let right = (region.x + region.width as i32) as f32;
            let bottom = (region.y + region.height as i32) as f32;

            // Check corners first
            if (pos.x - left).abs() <= threshold && (pos.y - top).abs() <= threshold {
                return Some(ResizeHandle::TopLeft);
            }
            if (pos.x - right).abs() <= threshold && (pos.y - top).abs() <= threshold {
                return Some(ResizeHandle::TopRight);
            }
            if (pos.x - left).abs() <= threshold && (pos.y - bottom).abs() <= threshold {
                return Some(ResizeHandle::BottomLeft);
            }
            if (pos.x - right).abs() <= threshold && (pos.y - bottom).abs() <= threshold {
                return Some(ResizeHandle::BottomRight);
            }

            // Check edges
            if pos.x >= left - threshold
                && pos.x <= right + threshold
                && (pos.y - top).abs() <= threshold
            {
                return Some(ResizeHandle::Top);
            }
            if pos.x >= left - threshold
                && pos.x <= right + threshold
                && (pos.y - bottom).abs() <= threshold
            {
                return Some(ResizeHandle::Bottom);
            }
            if pos.y >= top - threshold
                && pos.y <= bottom + threshold
                && (pos.x - left).abs() <= threshold
            {
                return Some(ResizeHandle::Left);
            }
            if pos.y >= top - threshold
                && pos.y <= bottom + threshold
                && (pos.x - right).abs() <= threshold
            {
                return Some(ResizeHandle::Right);
            }
        }

        None
    }
}

/// Run interactive overlay and return selected region
pub async fn run_interactive_overlay(
    options: InteractiveCaptureOptions,
) -> Result<ScreenshotResult, String> {
    // Create event loop
    let event_loop = EventLoop::new().map_err(|e| format!("Failed to create event loop: {}", e))?;

    // Create fullscreen transparent window
    let window_attributes = Window::default_attributes()
        .with_title("Screenshot Selection")
        .with_fullscreen(Some(winit::window::Fullscreen::Borderless(None)))
        .with_decorations(false)
        .with_transparent(true);

    let window = event_loop.create_window(window_attributes)
        .map_err(|e| format!("Failed to create window: {}", e))?;

    // Setup egui
    let mut egui_ctx = egui::Context::default();
    let mut egui_winit = egui_winit::State::new(
        egui_ctx.clone(),
        egui::ViewportId::ROOT,
        &window,
        None,
        None,
        None,
    );

    // Setup softbuffer for rendering
    let context = softbuffer::Context::new(&window)
        .map_err(|e| format!("Failed to create softbuffer context: {}", e))?;
    let mut surface = softbuffer::Surface::new(&context, &window)
        .map_err(|e| format!("Failed to create surface: {}", e))?;

    // Create shared state
    let state = Arc::new(Mutex::new(OverlayState::new(options)));
    let state_clone = Arc::clone(&state);

    // Result holder
    let result: Arc<Mutex<Option<Result<ScreenshotResult, String>>>> = Arc::new(Mutex::new(None));
    let result_clone = Arc::clone(&result);

    // Run event loop
    event_loop.run(move |event, elwt| {
        elwt.set_control_flow(ControlFlow::Wait);

        match event {
            Event::WindowEvent { event, .. } => {
                // Let egui handle the event first
                let response = egui_winit.on_window_event(&window, &event);

                if response.consumed {
                    return;
                }

                match event {
                    WindowEvent::CloseRequested => {
                        let mut result = result_clone.lock().unwrap();
                        *result = Some(Err("Cancelled by user".to_string()));
                        elwt.exit();
                    }
                    WindowEvent::MouseInput { state: button_state, button, .. } => {
                        let mut overlay_state = state_clone.lock().unwrap();

                        if button == MouseButton::Left {
                            match button_state {
                                ElementState::Pressed => {
                                    // Check if clicking on resize handle
                                    let handle = overlay_state.get_handle_at_pos(overlay_state.mouse_pos);

                                    if handle.is_some() {
                                        overlay_state.active_handle = handle;
                                    } else {
                                        // Start new selection
                                        overlay_state.drag_start = Some(overlay_state.mouse_pos);
                                        overlay_state.is_selecting = true;
                                        overlay_state.selection = None;
                                    }
                                }
                                ElementState::Released => {
                                    overlay_state.is_selecting = false;
                                    overlay_state.drag_start = None;
                                    overlay_state.active_handle = None;
                                }
                            }
                        }
                        window.request_redraw();
                    }
                    WindowEvent::CursorMoved { position, .. } => {
                        let mut overlay_state = state_clone.lock().unwrap();
                        overlay_state.mouse_pos = Pos2::new(position.x as f32, position.y as f32);

                        if overlay_state.is_selecting {
                            overlay_state.update_selection();
                        } else if overlay_state.active_handle.is_some() {
                            overlay_state.resize_selection();
                        }

                        window.request_redraw();
                    }
                    WindowEvent::KeyboardInput {
                        event: KeyEvent {
                            physical_key: PhysicalKey::Code(key_code),
                            state: ElementState::Pressed,
                            ..
                        },
                        ..
                    } => {
                        let mut overlay_state = state_clone.lock().unwrap();

                        match key_code {
                            KeyCode::Enter => {
                                // Confirm selection
                                overlay_state.confirmed = true;
                                window.request_redraw();
                            }
                            KeyCode::Escape => {
                                // Cancel
                                overlay_state.cancelled = true;
                                let mut result = result_clone.lock().unwrap();
                                *result = Some(Err("Cancelled by user".to_string()));
                                elwt.exit();
                            }
                            KeyCode::KeyF => {
                                // Toggle fullscreen selection
                                if let Some(monitor) = window.current_monitor() {
                                    let size = monitor.size();
                                    overlay_state.selection = Some(ScreenRegion {
                                        x: 0,
                                        y: 0,
                                        width: size.width,
                                        height: size.height,
                                    });
                                    window.request_redraw();
                                }
                            }
                            _ => {}
                        }
                    }
                    WindowEvent::RedrawRequested => {
                        let overlay_state = state_clone.lock().unwrap();

                        // Check if confirmed
                        if overlay_state.confirmed {
                            if let Some(region) = overlay_state.selection {
                                drop(overlay_state);

                                // Capture the selected region
                                let capture_result = tokio::runtime::Runtime::new()
                                    .unwrap()
                                    .block_on(capture_screen_region(Some(region)));

                                let mut result = result_clone.lock().unwrap();
                                *result = Some(capture_result);
                                elwt.exit();
                                return;
                            }
                        }

                        // Render UI
                        let raw_input = egui_winit.take_egui_input(&window);
                        let full_output = egui_ctx.run(raw_input, |ctx| {
                            render_overlay_ui(ctx, &overlay_state);
                        });

                        egui_winit.handle_platform_output(&window, full_output.platform_output);

                        // Render to softbuffer
                        let size = window.inner_size();
                        if size.width > 0 && size.height > 0 {
                            surface.resize(
                                size.width.try_into().unwrap(),
                                size.height.try_into().unwrap(),
                            ).ok();

                            if let Ok(mut buffer) = surface.buffer_mut() {
                                // Clear with semi-transparent black
                                for pixel in buffer.iter_mut() {
                                    *pixel = 0x80000000; // Semi-transparent black
                                }

                                // Paint egui
                                let clipped_primitives = egui_ctx.tessellate(full_output.shapes, full_output.pixels_per_point);
                                // Note: Full rendering would require converting egui shapes to pixels
                                // This is a simplified version

                                buffer.present().ok();
                            }
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }).map_err(|e| format!("Event loop error: {}", e))?;

    // Extract result
    let final_result = result.lock().unwrap();
    final_result.clone().unwrap_or_else(|| Err("No result".to_string()))
}

/// Render overlay UI with egui
fn render_overlay_ui(ctx: &egui::Context, state: &OverlayState) {
    egui::CentralPanel::default()
        .frame(egui::Frame::none())
        .show(ctx, |ui| {
            let painter = ui.painter();

            // Draw selection rectangle
            if let Some(region) = &state.selection {
                let rect = Rect::from_min_size(
                    Pos2::new(region.x as f32, region.y as f32),
                    Vec2::new(region.width as f32, region.height as f32),
                );

                // Draw border
                let border_color = if state.snapped_window.is_some() {
                    Color32::from_rgb(0, 255, 0) // Green when snapped
                } else {
                    Color32::from_rgb(0, 150, 255) // Blue normal
                };

                painter.rect_stroke(rect, 0.0, Stroke::new(2.0, border_color));

                // Draw resize handles
                draw_resize_handles(painter, &rect);

                // Draw info panel
                if state.options.show_size || state.options.show_coordinates {
                    let info_text = if state.options.show_size && state.options.show_coordinates {
                        format!("{}x{} at ({}, {})", region.width, region.height, region.x, region.y)
                    } else if state.options.show_size {
                        format!("{}x{}", region.width, region.height)
                    } else {
                        format!("({}, {})", region.x, region.y)
                    };

                    let text_pos = Pos2::new(region.x as f32 + 5.0, (region.y - 20).max(5) as f32);
                    painter.text(
                        text_pos,
                        egui::Align2::LEFT_TOP,
                        info_text,
                        egui::FontId::proportional(14.0),
                        Color32::WHITE,
                    );
                }

                // Draw hint text
                if let Some(hint) = &state.options.hint_text {
                    painter.text(
                        Pos2::new(10.0, 10.0),
                        egui::Align2::LEFT_TOP,
                        hint,
                        egui::FontId::proportional(16.0),
                        Color32::WHITE,
                    );
                }
            } else {
                // Show initial hint
                painter.text(
                    Pos2::new(10.0, 10.0),
                    egui::Align2::LEFT_TOP,
                    "Click and drag to select region. Press F for fullscreen, Enter to capture, Esc to cancel",
                    egui::FontId::proportional(16.0),
                    Color32::WHITE,
                );
            }
        });
}

/// Draw resize handles on selection rectangle
fn draw_resize_handles(painter: &egui::Painter, rect: &Rect) {
    let handle_size = 8.0;
    let handle_color = Color32::from_rgb(255, 255, 255);

    // Corner handles
    draw_handle(painter, rect.left_top(), handle_size, handle_color);
    draw_handle(painter, Pos2::new(rect.right(), rect.top()), handle_size, handle_color);
    draw_handle(painter, rect.left_bottom(), handle_size, handle_color);
    draw_handle(painter, rect.right_bottom(), handle_size, handle_color);

    // Edge handles
    draw_handle(painter, Pos2::new(rect.center().x, rect.top()), handle_size, handle_color);
    draw_handle(painter, Pos2::new(rect.center().x, rect.bottom()), handle_size, handle_color);
    draw_handle(painter, Pos2::new(rect.left(), rect.center().y), handle_size, handle_color);
    draw_handle(painter, Pos2::new(rect.right(), rect.center().y), handle_size, handle_color);
}

/// Draw a single resize handle
fn draw_handle(painter: &egui::Painter, center: Pos2, size: f32, color: Color32) {
    let rect = Rect::from_center_size(center, Vec2::splat(size));
    painter.rect_filled(rect, 1.0, color);
    painter.rect_stroke(rect, 1.0, Stroke::new(1.0, Color32::BLACK));
}
