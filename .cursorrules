# Aumate é¡¹ç›®å¼€å‘è§„èŒƒ

## ğŸ—ï¸ æ¶æ„åŸåˆ™

### DDD åˆ†å±‚æ¶æ„

æœ¬é¡¹ç›®é‡‡ç”¨ Domain-Driven Design (DDD) åˆ†å±‚æ¶æ„ï¼Œä¸¥æ ¼éµå¾ªä¾èµ–å€’ç½®åŸåˆ™ï¼š

```
API Layer (Tauri Commands)
    â†“ è°ƒç”¨
Application Layer (Use Cases)
    â†“ ä¾èµ–æ¥å£
Domain Layer (Ports - Traitæ¥å£)
    â†‘ å®ç°æ¥å£
Infrastructure Layer (Adapters)
```

### æ ¸å¿ƒè§„åˆ™

1. **ä¾èµ–æ–¹å‘**
   - Domain Layer å®šä¹‰æ¥å£ï¼ˆPortsï¼‰ï¼Œä¸ä¾èµ–ä»»ä½•å…¶ä»–å±‚
   - Infrastructure Layer å®ç°æ¥å£ï¼ˆAdaptersï¼‰
   - Application Layer é€šè¿‡æ¥å£è°ƒç”¨ï¼Œä¸ç›´æ¥ä¾èµ–å…·ä½“å®ç°
   - API Layer ä»…åšå‚æ•°éªŒè¯å’Œè°ƒç”¨ Use Cases

2. **å•ä¸€èŒè´£**
   - API Layer: å‚æ•°éªŒè¯ã€é”™è¯¯è½¬æ¢
   - Application Layer: ä¸šåŠ¡æµç¨‹ç¼–æ’
   - Domain Layer: é¢†åŸŸæ¨¡å‹å’Œä¸šåŠ¡è§„åˆ™
   - Infrastructure Layer: æŠ€æœ¯å®ç°ç»†èŠ‚

3. **å‘½åçº¦å®š**
   - Portæ¥å£: `xxxPort` (å¦‚ `ScreenCapturePort`)
   - Adapterå®ç°: `xxxAdapter` (å¦‚ `ScreenCaptureAdapter`)
   - Use Case: `xxxUseCase` (å¦‚ `CaptureScreenUseCase`)
   - DTO: `xxxDto` / `xxxRequest` / `xxxResponse`

## ğŸ“¦ ä»£ç ç»„ç»‡

### Crate ç»“æ„

```
crates/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ shared/       # å…±äº«ç±»å‹ã€é”™è¯¯å®šä¹‰
â”‚   â”œâ”€â”€ domain/       # é¢†åŸŸæ¨¡å‹
â”‚   â””â”€â”€ traits/       # Port æ¥å£å®šä¹‰
â”œâ”€â”€ application/      # Use Cases + DTOs
â””â”€â”€ infrastructure/   # Adapters + Services

aumate-app/src-tauri/ # API Layer (åº”ç”¨ç‰¹å®š)
â””â”€â”€ src/
    â”œâ”€â”€ commands/     # Tauri Commands
    â”œâ”€â”€ state.rs      # AppState
    â””â”€â”€ setup.rs      # ä¾èµ–æ³¨å…¥
```

### æ–°åŠŸèƒ½å®ç°æµç¨‹

å½“æ·»åŠ æ–°åŠŸèƒ½æ—¶ï¼ŒæŒ‰ç…§ä»¥ä¸‹é¡ºåºå®ç°ï¼š

#### 1. Domain Layer - å®šä¹‰æ¥å£

**ä½ç½®**: `crates/core/traits/src/`

```rust
// crates/core/traits/src/my_feature.rs
use async_trait::async_trait;
use aumate_core_shared::InfrastructureError;

#[async_trait]
pub trait MyFeaturePort: Send + Sync {
    async fn do_something(&self) -> Result<MyResult, InfrastructureError>;
}
```

**å¯¼å‡º**: åœ¨ `crates/core/traits/src/lib.rs` ä¸­æ·»åŠ ï¼š
```rust
pub mod my_feature;
pub use my_feature::MyFeaturePort;
```

#### 2. Infrastructure Layer - å®ç° Adapter

**ä½ç½®**: `crates/infrastructure/src/adapters/`

```rust
// crates/infrastructure/src/adapters/my_feature.rs
use async_trait::async_trait;
use aumate_core_traits::MyFeaturePort;

pub struct MyFeatureAdapter {
    // å­—æ®µ
}

impl MyFeatureAdapter {
    pub fn new() -> Self {
        Self {}
    }
}

#[async_trait]
impl MyFeaturePort for MyFeatureAdapter {
    async fn do_something(&self) -> Result<MyResult, InfrastructureError> {
        // å®ç°é€»è¾‘
        // å¦‚æœéœ€è¦å¹³å°ç‰¹å®šä»£ç ï¼Œä½¿ç”¨ï¼š
        #[cfg(target_os = "macos")]
        {
            // macOS å®ç°
        }
        
        #[cfg(target_os = "windows")]
        {
            // Windows å®ç°
        }
    }
}
```

**å¹³å°ç‰¹å®šä»£ç ** (å¦‚éœ€è¦):
- ä½ç½®: `crates/infrastructure/src/platform/macos/` (æˆ– `windows/`, `linux/`)
- åœ¨ Adapter ä¸­è°ƒç”¨å¹³å°ç‰¹å®šå‡½æ•°

**å¯¼å‡º**: åœ¨ `crates/infrastructure/src/adapters/mod.rs` ä¸­æ·»åŠ ï¼š
```rust
pub mod my_feature;
pub use my_feature::MyFeatureAdapter;
```

#### 3. Application Layer - Use Case + DTO

**Use Case** (`crates/application/src/use_cases/my_feature.rs`):
```rust
use aumate_core_shared::UseCaseError;
use aumate_core_traits::MyFeaturePort;
use std::sync::Arc;

pub struct MyFeatureUseCase {
    feature: Arc<dyn MyFeaturePort>,
}

impl MyFeatureUseCase {
    pub fn new(feature: Arc<dyn MyFeaturePort>) -> Self {
        Self { feature }
    }

    pub async fn execute(&self) -> Result<MyResultDto, UseCaseError> {
        log::info!("[MyFeatureUseCase] Executing");

        let result = self.feature
            .do_something()
            .await
            .map_err(|e| e.into())?;

        // è½¬æ¢ä¸º DTO
        Ok(result.into())
    }
}
```

**DTO** (`crates/application/src/dto/my_feature.rs`):
```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MyResultDto {
    // å­—æ®µ
}

// å®ç° From trait è¿›è¡Œè½¬æ¢
impl From<DomainType> for MyResultDto {
    fn from(value: DomainType) -> Self {
        Self {
            // è½¬æ¢é€»è¾‘
        }
    }
}
```

**å¯¼å‡º**: 
- `crates/application/src/use_cases/mod.rs` æ·»åŠ  `pub mod my_feature;` å’Œ `pub use my_feature::*;`
- `crates/application/src/dto/mod.rs` æ·»åŠ  `pub mod my_feature;` å’Œ `pub use my_feature::*;`

#### 4. API Layer - Tauri Command (ä»…åœ¨åº”ç”¨å±‚)

**æ³¨æ„**: API commands åªåœ¨ `aumate-app/src-tauri/src/commands/` ä¸­ï¼Œä¸åœ¨ crates é‡Œ

**ä½ç½®**: `aumate-app/src-tauri/src/commands/my_feature.rs`

```rust
use crate::state::AppState;
use aumate_application::dto::MyResultDto;
use aumate_core_shared::ApiError;
use tauri::State;

#[tauri::command]
pub async fn do_my_feature(
    state: State<'_, AppState>,
) -> Result<MyResultDto, String> {
    log::info!("API: do_my_feature called");

    state.my_feature_use_case
        .execute()
        .await
        .map_err(|e| {
            let api_error: ApiError = e.into();
            api_error.to_string()
        })
}
```

**æ³¨å†Œå‘½ä»¤**: åœ¨ `aumate-app/src-tauri/src/lib.rs` çš„ `invoke_handler` ä¸­æ·»åŠ 

#### 5. ä¾èµ–æ³¨å…¥ - AppState

**State** (`aumate-app/src-tauri/src/state.rs`):
```rust
pub struct AppState {
    // ... existing fields ...
    pub my_feature_adapter: Arc<MyFeatureAdapter>,
    pub my_feature_use_case: Arc<MyFeatureUseCase>,
}
```

**Setup** (`aumate-app/src-tauri/src/setup.rs`):
```rust
pub fn setup_application() -> AppState {
    // 1. åˆ›å»º Adapter
    let my_feature_adapter = Arc::new(MyFeatureAdapter::new());
    
    // 2. åˆ›å»º Use Case
    let my_feature_use_case = Arc::new(MyFeatureUseCase::new(
        my_feature_adapter.clone()
    ));
    
    // 3. è¿”å› AppState
    AppState {
        // ... existing fields ...
        my_feature_adapter,
        my_feature_use_case,
    }
}
```

## âš ï¸ é‡è¦ç¦æ­¢äº‹é¡¹

### âŒ ä¸è¦åœ¨ Commands ä¸­ç›´æ¥å®ç°ä¸šåŠ¡é€»è¾‘

**é”™è¯¯ç¤ºä¾‹**:
```rust
#[tauri::command]
pub async fn get_window_elements() -> Result<Vec<WindowElement>, String> {
    // âŒ é”™è¯¯ï¼šç›´æ¥åœ¨ command ä¸­å®ç°é€»è¾‘
    #[cfg(target_os = "macos")]
    {
        use core_graphics::window::CGWindowListCopyWindowInfo;
        // ... å¤§é‡å®ç°ä»£ç  ...
    }
}
```

**æ­£ç¡®åšæ³•**:
```rust
#[tauri::command]
pub async fn get_window_elements(
    state: State<'_, AppState>
) -> Result<Vec<WindowElementDto>, String> {
    // âœ… æ­£ç¡®ï¼šä»…è°ƒç”¨ Use Case
    state.get_window_elements
        .execute()
        .await
        .map_err(|e| e.into())
}
```

### âŒ ä¸è¦è·¨å±‚ç›´æ¥ä¾èµ–

- Domain Layer ä¸èƒ½ä¾èµ– Infrastructure/Application/API
- Application Layer ä¸èƒ½ç›´æ¥ä¾èµ– Adapter å®ç°ï¼ˆåªèƒ½ä¾èµ– Port æ¥å£ï¼‰
- Infrastructure Layer ä¸èƒ½ä¾èµ– Application/API

### âŒ ä¸è¦åœ¨é”™è¯¯çš„åœ°æ–¹å®šä¹‰ç±»å‹

- é¢†åŸŸæ¨¡å‹: `core/domain/` (å¦‚ `Image`, `Screenshot`)
- å…±äº«ç±»å‹: `core/shared/` (å¦‚ `Rectangle`, `Point`, `MonitorId`)
- DTO: `application/dto/` (ç”¨äº API å“åº”)
- Port æ¥å£: `core/traits/`

## ğŸ” ä»£ç å®¡æŸ¥æ¸…å•

æäº¤ä»£ç å‰ï¼Œæ£€æŸ¥ï¼š

- [ ] æ–°åŠŸèƒ½æ˜¯å¦æŒ‰ç…§ DDD åˆ†å±‚å®ç°ï¼Ÿ
- [ ] Port æ¥å£æ˜¯å¦åœ¨ `core/traits` å®šä¹‰ï¼Ÿ
- [ ] Adapter æ˜¯å¦åœ¨ `infrastructure/adapters` å®ç°ï¼Ÿ
- [ ] Use Case æ˜¯å¦åœ¨ `application/use_cases` å®ç°ï¼Ÿ
- [ ] DTO æ˜¯å¦åœ¨ `application/dto` å®šä¹‰ï¼Ÿ
- [ ] API Command æ˜¯å¦åªåšå‚æ•°éªŒè¯å’Œè°ƒç”¨ Use Caseï¼Ÿ
- [ ] æ˜¯å¦æ›´æ–°äº†æ¨¡å—å¯¼å‡º (`mod.rs`, `lib.rs`)?
- [ ] æ˜¯å¦æ›´æ–°äº† `AppState` å’Œ `setup_application`ï¼Ÿ
- [ ] æ˜¯å¦åœ¨ `lib.rs` ä¸­æ³¨å†Œäº†æ–°çš„ commandï¼Ÿ
- [ ] æ˜¯å¦æ›´æ–°äº†ç›¸å…³æ–‡æ¡£ (README.md, ARCHITECTURE.md)?
- [ ] ä»£ç æ˜¯å¦é€šè¿‡ `cargo check --workspace` æ£€æŸ¥ï¼Ÿ
- [ ] æ˜¯å¦æ·»åŠ äº†å¿…è¦çš„æµ‹è¯•ï¼Ÿ

## ğŸ“ å¸¸ç”¨å‘½ä»¤

```bash
# æ£€æŸ¥æ•´ä¸ªå·¥ä½œåŒº
cargo check --workspace

# æ£€æŸ¥ç‰¹å®š crate
cargo check --package aumate-infrastructure

# è¿è¡Œæµ‹è¯•
cargo test --workspace

# æ ¼å¼åŒ–ä»£ç 
cargo fmt --all

# Lint æ£€æŸ¥
cargo clippy --workspace -- -D warnings

# ç¼–è¯‘å‘å¸ƒç‰ˆæœ¬
cd aumate-app && pnpm tauri build
```

## ğŸ”— ç›¸å…³æ–‡æ¡£

- æ¶æ„è¯¦è§£: `crates/docs/ARCHITECTURE.md`
- é¡¹ç›®æ¦‚è§ˆ: `crates/docs/README.md`
- å‘½ä»¤å˜æ›´: `crates/docs/COMMANDS_CHANGELOG.md`

---

**è®°ä½**: ä¿æŒæ¶æ„æ¸…æ™°ï¼Œä»£ç ç»„ç»‡æœ‰åºï¼Œéµå¾ª DDD åŸåˆ™ï¼Œè®©ä»£ç æ›´æ˜“ç»´æŠ¤å’Œæ‰©å±•ï¼
